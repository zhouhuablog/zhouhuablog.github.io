---
author: admin
comments: true
date: 2009-12-22 13:12:30+00:00
layout: post
slug: 0912222006
title: 在类的成员函数中调用delete this
published: false
wordpress_id: 99
categories:
- 默认
tags:
- delete
- 析构函数
- 虚函数表
---

这篇博客本来上周日就应该写出来了，为什么呢？因为我周六晚上做梦的时候梦见这篇博文了，本来决定周日趁着还记得挺清楚直接写出来的，结果有事耽搁了，就一直拖到现在。周日早上我跟女朋友说做梦的事儿，她给了我一句评语，“你都快没生活情趣了，天天就想着这些东西。想着就算了，竟然还梦见了，天啊！”，哈哈。闲话少续，说说正经的。

---------------------------------------------------正式开始的分割线----------------------------------------------------

上周在刘未鹏老大的[TopLanguage](https://groups.google.com/group/pongba)(很遗憾，google groups被墙了，请翻墙查看该链接)里看到个讨论，似乎是说C++最佳面试题的，题目是“在类的成员函数中能不能调用delete this？”。由于我这个人忘性太大(上周五在toplanguage里潜水一下午看讨论，今天就忘光了)，把现在能想起来的部分内容记在这里。

在类的成员函数中能不能调用delete this？答案是肯定的，能调用，而且很多老一点的库都有这种代码。假设这个成员函数名字叫release，而delete this就在这个release方法中被调用，那么这个对象在调用release方法后，还能进行其他操作，如调用该对象的其他方法么？答案仍然是肯定的，调用release之后还能调用其他的方法，但是有个前提：被调用的方法不涉及这个对象的数据成员和虚函数。说到这里，相信大家都能明白为什么会这样了。

根本原因在于delete操作符的功能和类对象的内存模型。当一个类对象声明时，系统会为其分配内存空间。在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现**不可预期**的问题。

为什么是不可预期的问题？delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。

<!-- more -->
大致明白在成员函数中调用delete this会发生什么之后，再来看看另一个问题，如果在类的析构函数中调用delete this，会发生什么？实验告诉我们，会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”(来自effective c++)。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。

关于delete this就总结到这里，若有错漏，欢迎留言指正。2009年12月22日。


#### **-----------------------------------------补充的分割线----------------------------------------------------**




#### **看到一个成员函数调用delete this的案例，在boost源码中，路径：boost\smart_ptr\detail\sp_counted_base_w32.hpp，这个文件中就是sp_counted_base类的实现代码，在sp_counted_base类的destroy方法里面，调用了delete this。源码如下：**




#### **virtual void destroy() // nothrow**


** **

**


#### **


### **


## **{**


**


**




#### **


### **


## **delete this;**


**


**




#### **


### **


## **}**


**


**


**
