---
author: admin
comments: true
date: 2009-12-14 14:19:11+00:00
layout: post
slug: 0912142042
published: false
title: 虚函数表与函数指针数组
wordpress_id: 41
categories:
- 默认
tags:
- 函数指针
- 虚函数表
---

从收藏夹里翻出个放了很久的帖子，内容是关于类对象中的虚函数指针和虚函数表的。想看具体内容请猛击[这里](http://www.uml.org.cn/c%2B%2B/200811143.asp)。

根据帖子内容和自己的认识，总结以下几点：

1、虚函数表指针位于类对象内存模型中的最前端，也就是说，一个类对象在内存中的地址范围内，前4个字节存放的是虚函数表的首地址，可以通过这个首地址访问到虚函数表。在上面的帖子里的第一个示例中，虚函数表的首地址就是：(int*)(*(int *) &b)；

2、虚函数表中存放的是类对象的虚成员函数的首地址。虚函数表中的每一项又是一个指针，指向的是该虚成员函数的首地址，所以，可以通过虚函数表调用虚成员函数。还是上面帖子里的第一个例子，调用第一个虚成员函数的语句：

pFun = (Fun)*((int*)*(int*)(&b));
pFun();

其中，(int*)*(int*)(&b)就是虚函数表的第一项的地址。反引用之后，*((int*)*(int*)(&b))得到的就是第一个虚成员函数的首地址。将其强制转换后赋给函数指针pFun，此时，pFun指向的就是第一个虚成员函数的首地址，所以pFun()能够调用到Base::f。

3、在无虚函数覆盖的继承关系中，“虚函数按照其声明顺序放于表中”，并且“父类的虚函数在子类的虚函数前面”。

4、在有虚函数覆盖的继承关系中，子类中的函数覆盖掉父类的虚函数，覆盖的虚函数放到了虚函数表中父类被覆盖虚函数的位置，而“没有被覆盖的函数依旧”。这样的虚函数表结构，在实际调用过程中形成了多态。

5、对于多重继承，在子类的内存模型中，“每个父类都有自己的虚表”，“子类的成员函数被放到了第一个父类的表中”，其中“所谓的第一个父类是按照声明顺序来判断的”。

6、存在覆盖的多重继承中，子类的覆盖函数将取代其覆盖掉的父类的虚函数在虚函数表中的位置。


其实想起来去看虚函数表相关内容是因为在《高质量程序设计指南-C++/C》上看到一句话：在C++动态决议的虚拟机制中使用的vtable就是一个用来保存虚成员函数的地址的函数指针数组。看完虚函数表相关内容之后，稍微调整帖子里第一个例子的代码：
<!-- more -->
class Base
{
public:
virtual void f() { cout << "Base::f" << endl; }
virtual void g(int i) { cout << "Base::g(int)" << endl; }
virtual void h() { cout << "Base::h" << endl; }
};

int main(void)
{
typedef void(*Fun)(void);

Base b;

Fun pFun = NULL;

cout << "虚函数表地址：" << (int*)(&b) << endl;
cout << "虚函数表 — 第一个函数地址：" << (int*)*(int*)(&b) << endl;

// Invoke the first virtual function
pFun = (Fun)*((int*)*(int*)(&b));
pFun();
}

输出：

虚函数表地址：0012FF60
虚函数表 — 第一个函数地址：00419B80
Base::f

VS2005调试状态下查看对象b的虚函数表是这样的

![虚函数表](http://blog.huubby.tk/wp-content/uploads/2009/12/bmp)

通过上面总结的虚函数表的第二点内容，可以设计程序验证，虚函数表中地址是连续的，并且虚函数表中第二项的值是0x0041132a，与图中是一致的。看起来虚函数表vtable确实是一个函数指针数组。

暂停下，先来看看函数指针数组的声明和使用。

double (*fp[6])(double) = { sqrt, fabs, cos, sin, exp, log };
for (int i = 0; i < 6; i++)
{
cout<<"Result: "<<fp[i](10.25)<<endl;
}

在这里，函数指针数组必须是原型一致的函数的函数名的集合，否则编译都无法通过。例如，把

double (*fp[6])(double) = { sqrt, fabs, cos, sin, exp, log };

改成

double (*fp[7])(double) = { sqrt, fabs, cos, sin, exp, log, fmod };

这时，编译器在编译时就会报错，因为fmod的原型是：

double  fmod(double , double);

而在前一个例子中，虚函数Base::g(int)明显与虚函数Base::f()原型不一致。

问题来了，虚函数表是通过函数指针数组实现的，那么这个函数指针数组是怎么调用不同原型函数的呢？虚函数表与普通的函数指针数组又有哪些区别和联系？

又一个不知道答案的问题。

2009年12月14日 21：59 于家中。

**------------------------编辑的分割线---------------------------------------**

**多方请教，得到如下结果：**

**第一，编译器并不是将C++转化成C再编译（虽然早期确实是这样），因此不受C语法的限制；**

**第二，编译器本身知道所有函数的原型，在调用某个具体函数时可以直接将对应的参数做栈操作即可。**

**关于第二点，还要进一步了解编译器机制，暂时还深入不到这种程度。**

**解答来自TopLanguage的Googol Lee，在此致谢。**
